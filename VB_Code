'Global Var Definitions
Public Letters(2 To 9, 1 To 4) As String
Public Diagram(2 To 9, 1 To 4) As String
Public Special(2 To 9, 1 To 4) As String
Public Dictionary_Words(1 To 180580) As String
Public Adj_List(2 To 9, 1 To 4) As String
Public lookup_word As String
Public lookup_len As Integer
Public Output_Test(2 To 9, 1 To 4) As String
Public Output_Words(1 To 180580) As String
Public boardPositionUsed(2 To 9, 1 To 4) As Boolean
Public outputPath_List(1 To 180580) As String
Public outputWord_List(1 To 180580) As String
Public output_index As Integer


Sub Rectangle1_Click()
'main steps to split up into parts for easier adaptation to environment/customization:
    '1. user input read and association of properties
        Call inputs
       
    '2. dictionary read
        Call dictionary_read
    
    '3. prepro of dictionary if any
        
    '4. subroutine to create list of possible moves
        output_index = 0
        
      Call get_adjacent
    
    '5. assignment of weights to possible moves list
    '6. eventually an iterative step to look multiple moves out and clear gems/count down to end of game.
    '7. results display
        Call Output
         
End Sub
Function path_to_word(inputString As String) As String

Dim word As String
Dim path_length As Integer
Dim entries As Integer
Dim i As Integer
Dim rownum As Integer
Dim colnum As Integer


path_length = Len(inputString)

'determine length, that /2 is num of board entries
entries = path_length / 2

'initialize word to blank
word = ""


For i = 1 To entries
'loop for each entry, get two "digit" substring of the path string
    'so first entry is the first two digits of the string
    'conversion formula is col is first digit, row is second
        colnum = CInt(Mid(inputString, 2 * i - 1, 1))
        rownum = CInt(Mid(inputString, 2 * i, 1))
    'then retrieve the board position's letters
    'concatenate to word
    'return word
        word = word + Letters(rownum, colnum)
Next i
path_to_word = word

End Function
Function boardPath_Recursive(i As String) As String
Dim word As String
Dim row_iterator As Integer
Dim col_iterator As Integer
row_iterator = 0
col_iterator = 0
Dim all_adjacent_used As Boolean
all_adjacent_used = True
Dim active_tile As String
Dim active_tile_row As Integer
Dim active_tile_col As Integer
Dim exit_condition_met As Boolean


'to simplify life changing from col-row notation to board position notation as:
' 11 21 31 41   actually coded in letters as rows from 2 to 5
' 12 22 32 42
' 13 23 33 43
' 14 24 34 44
'either or issue?
'hidden second board that is empty coded with +4 to the row.
'or board
'15 25 35 45
'16 26 36 46
'17 27 37 47
'18 28 38 48

'conversion formula is concatenation of col num and row num

'input board sequence
'output board sequence

'get word from board path using function path_to_word and check for it in the dictionary
lookup_word = path_to_word(i)
lookup_len = Len(lookup_word)
active_tile = Right(i, 2)
active_tile_col = CInt(Left(active_tile, 1))
active_tile_row = CInt(Right(active_tile, 1))
exit_condition_met = False

If Len(i) = 32 Then
    exit_condition_met = True
     If (dictionary_lookup() = True) Then
    output_index = output_index + 1
    'write word to possible outputs list
        outputWord_List(output_index) = lookup_word
    'write path to possible paths list
        outputPath_List(output_index) = i
    'return with path
    boardPath_Recursive = i
Else
    For row_iterator = active_tile_row - 1 To active_tile_row + 1
        For col_iterator = active_tile_col - 1 To active_tile_col + 1
            'if not the same tile and not used
            If (!boardPositionUsed(row_iterator, col_iterator)) And (row_iterator <> active_tile_row Or col_iterator <> active_tile_col) And (Diagram(active_tile_row, active_tile_col) <> "Ends With") Then
                If (Diagram(row_iterator, col_iterator) <> "Begins With") Then
                    all_adjacent_used = False
                End If
            End If
        Next col_iterator
    Next row_iterator
    If all_adjacent_used Then
        exit_condition_met = True
    End If
End If


If (!exit_condition_met) Then
    'if word is in dictionary
    If (dictionary_lookup() = True) Then
      output_index = output_index + 1
    'write word to possible outputs list
        outputWord_List(output_index) = lookup_word
    'write path to possible paths list
        outputPath_List(output_index) = i
    End If
    'find adjacent board entry to last board path position
    'look to adjacent entries
    'call recursive board path with adjacent paths
    For row_iterator = active_tile_row - 1 To active_tile_row + 1
        For col_iterator = active_tile_col - 1 To active_tile_col + 1
            'if not the same tile and not used
            If (!boardPositionUsed(row_iterator, col_iterator)) And (row_iterator <> active_tile_row Or col_iterator <> active_tile_col) And (Diagram(active_tile_row, active_tile_col) <> "Ends With") Then
                If (Diagram(row_iterator, col_iterator) <> "Begins With") Then
                'unique new tile unused and not a begins with
                'append to boardPath after converting to position
                'logic for either or
                
                End If
            End If
        Next col_iterator
     Next row_iterator
End If

End Function

Sub clearUsed()
Dim i As Integer
Dim j As Integer

For i = 2 To 9
    For j = 1 To 4
    
    boardPositionUsed(i, j) = False
    
    Next j
Next i
    
End Sub
Function parse_cell(instring As String) As String
    If (Left(instring, 1)) = "-" Then
        parse_cell = "Ends With"
    ElseIf (Right(instring, 1)) = "-" Then
        parse_cell = "Begins With"
    ElseIf (Mid(instring, 2, 1) = "/") Then
        parse_cell = "Either Or"
    Else
        parse_cell = "None"
    End If
        
End Function
Function dictionary_lookup() As Boolean
'given a string input cycle through dictonary words looking for a word starting with the same sequence

'return a true or false for if a word is present in the dictionary or not found for now
Dim i As Long
For i = 1 To 180580
    Output_Words(i) = ""
    If Left(Dictionary_Words(i), lookup_len) = lookup_word Then
        dictionary_lookup = True
        i = 180580 ' in other words, stop looking and just add the substr.
        If (Len(Dictionary_Words(i)) = lookup_len) Then
        Output_Words(i) = Dictionary_Words(i)
        End If
    Else
        dictionary_lookup = False
    End If
Next i
            
End Function
Sub get_adjacent()
Dim i As Integer
Dim j As Integer
Dim x As Integer, y As Integer
Dim i_up As Integer, i_low As Integer
Dim j_up As Integer, j_low As Integer
'using recursion
'try dfs approach

'recursive algorithm for getting substring from adjacent blocks
' takes in a board position (which contains a string and other information)? or takes in a string? or both
' results in a string or sequence of board positions?

'what is my basis case?

'return when matching substr in dictionary of length substr
'call new instance when substr in dictionary but not == length







For i = 2 To 5
    For j = 1 To 4
        Call clearUsed
        ' cycling through each row then each column to look at the board substring
        ' find list of words that start with this board position
        'when doing a recursion, simply check for "Ends With" and then don't originate from this board's substring
        If (Diagram(i, j) <> "Ends With") Then
        'start from this position and look for more board entries to add.
        boardPositionUsed(i, j) = True
        'cycling through adjacent rows and columns to look at nearby board entries
        For x = i - 1 To i + 1
            For y = j - 1 To j + 1
               
            
                If ((x <> i Or j <> y) And (x > 1 And x < 6) And (y > 0 And y < 5)) Then
                 'when doing recursion, if it is "Begins With" only originate
                If (Diagram(x, y) <> "Begins With") And (boardPositionUsed(x, y) = False) Then
                
                'satisfies adjacent board entry, not used.
                'when doing recursion on "Either Or" allow two options for the next call
                
                'need all possible adjacencies, dictionary lookup done elsewhere
                
                
                
                
                '--rerwrite from here
                
                   
                ' either or will have to branch to two possibilities - this is x y case.
                    If (Diagram(x, y) = "Either Or") Then
                    lookup_word = Letters(i, j) + Letters(x, y)
                    lookup_len = Len(lookup_word)
                    Adj_List(i, j) = Adj_List(i, j) + "  " + Letters(i, j) + Letters(x, y)
                   
                    lookup_word = Letters(i, j) + Letters(x + 4, y)
                    lookup_len = Len(lookup_word)
                    Adj_List(i, j) = Adj_List(i, j) + "  " + Letters(i, j) + Letters(x + 4, y)
                    
                    Else ' else of either or x y
                    lookup_word = Letters(i, j) + Letters(x, y)
                    Adj_List(i, j) = Adj_List(i, j) + " " + Letters(i, j) + Letters(x, y)
                    lookup_len = Len(lookup_word)
                    End If
                    
                   
                   
                  
                    
                       '--- rewrite to here
                       
                       
                       
                       
                       
                    End If ' end if for check on valid x,y
      
                End If 'end if for if x,y were not an ends with
            Next y
        Next x
            
    Output_Test(i, j) = Adj_List(i, j)
    End If 'end if for if i,j is not a ends with
    Next j
Next i




End Sub
Sub dictionary_read()
'set word range to first column of words given by the words used in scrabble plus all the words in english language 9 letters to 16.
Dim Dictionary As Worksheet
  Set Dictionary = ActiveWorkbook.Sheets("Sheet2")
  Dim dict As Range
  Set dict = Dictionary.Range("A2:A180580")
'we can go two paths here, create an array of possible substrings and pass that, which i think is kind of a bad idea, i think it
'it would be wiser to re-parse the substring as needed
' i do however think it is smart to at this point create the necessary size dictionary to memory, maybe? that or start the algorithm here.
' if i recall correctly passing from cell value to memory is expensive, but once an object is created in memory in VBA it is easier accessed.

For Each cell In dict
  Dictionary_Words(cell.row) = cell.Value
Next cell
  

End Sub


Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    Application.ScreenUpdating = False
    ' Clear the color of all the cells
    Cells.Interior.ColorIndex = 0
    ' Highlight the active cell
    Target.Interior.ColorIndex = 8
    Application.ScreenUpdating = True
End Sub
Sub Output()
'writing to workbook
'currently testing just getting the input and re-writing
    Dim Output As Range
    Set Output = Range("e2:h5")
    For Each cell In Output
        cell.Value = Output_Test(cell.row, cell.Column - 4)
    Next cell

End Sub

Sub inputs()
' when will VBA EVER have block comments??
'user input read
'RM1 assumes workbook entry is formatted as a grid so position is inherent to cell and user is confined to area in worksheet.
'FW1 parse string in each cell will be required to discover properties. Initally no diagram restriction properties allowed. add later and test
'FW2 all letters will assumed to not be special to start with to avoid weighting problem until after other issues are debugged.
'RM2 general approach:
    '1 define variables: input range, (public) (static?) 3 2-dimensional arrays to hold for each board position the 3 major properties therein: letters present, diagram restriction, special bonus.
    '2 cycle through range, assign to each array the letter, and properties.
  Dim userInput As Range
 Set userInput = Range("A2:D5")

    For Each cell In userInput
        Letters(cell.row, cell.Column) = cell.Value
        'FW1 add parse string to find special diagram notes
        Diagram(cell.row, cell.Column) = parse_cell(cell.Value)
        If (Diagram(cell.row, cell.Column) = "Begins With") Then
            Letters(cell.row, cell.Column) = Left(cell.Value, Len(cell.Value) - 1)
            'cell.Value = Letters(cell.row, cell.Column)
        End If
        If (Diagram(cell.row, cell.Column) = "Ends With") Then
            Letters(cell.row, cell.Column) = Right(cell.Value, Len(cell.Value) - 1)
             'cell.Value = Letters(cell.row, cell.Column)
        End If
        If (Diagram(cell.row, cell.Column) = "Either Or") Then
            Letters(cell.row, cell.Column) = Left(cell.Value, 1)
            Letters(cell.row + 4, cell.Column) = Right(cell.Value, 1)
            Diagram(cell.row + 4, cell.Column) = "Either Or"
            Special(cell.row + 4, cell.Column) = 1
             'cell.Value = Letters(cell.row, cell.Column)
        End If
            
        
        'FW2 add find highlighting code to get properties
        Special(cell.row, cell.Column) = 1
    Next cell

End Sub




